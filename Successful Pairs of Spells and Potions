class Solution {
    public int[] successfulPairs(int[] spells, int[] potions, long success) {
    
//binary search krrenge
int n=potions.length;
Arrays.sort(potions);
int []result =new int[spells.length];

for (int i=0;i<spells.length;i++) {
    long minimumpotion =(success+spells[i]-1)/spells[i];

    int lower=0; 
    int rightboundary=n;
    while(lower<rightboundary){
        int mid=(lower+rightboundary)/2;
        if(potions[mid]<minimumpotion){
            lower=mid+1;
        }else rightboundary=mid;
        }
        result[i]=n-lower;
    }


return result;
    






/**
spell*potion≥success
spells[i]×potion≥success
potion≥spells[i]/success​

 */
       //TLE ERROR BKC 
// int[] result = new int[spells.length];
// for(int i=0;i<spells.length;i++){
//     int count=0; 
//     for(int j=0;j<potions.length;j++){
//         if((long)spells[i]*potions[j]>=success){  //long missing tha bc
//             count ++;
//         }
//     }
// result[i]=count;
// }
// return result;
/**Sort the potions array to enable binary search.

For each spell, calculate the minimum potion strength needed: minimumPotion = ceil(success / spell).

Use binary search to find the first potion ≥ minimumPotion.

The number of successful pairs for that spell = total potions - index found. */
    }
}
